import os
import hashlib
import re, ast
import array, math


location_dir = os.path.dirname(os.path.abspath(__file__))

# location_dir = "/mnt/home/james/checkouts/adam_b_project/host_im/mount/malware-classification-master"

good=location_dir+"/samples/not/"
bad=location_dir+"/samples/virus/"

headers=[
    "Name", 
    "md5", 
    "entropy", 
    "imports", 
    "good", 
    "bad", 
    "line count",
    "mean name length", 
    "variable entropy", 
    "contains ip address",
    "legitimate"
    ]


def get_entropy(data):
    if len(data) == 0:
	    return(0.0)
    occurences = array.array('L', [0]*256)
    for x in data:
  	    occurences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x*math.log(p_x, 2)

            return entropy


def get_average_name_length(data):
    '''Takes in a python .py file as a string in data. Picks out all 
    of the function, variable and class names and stores them in a 
    seperate string to make an average length calculation.
        data: input .py string information.
        variables_list: stores the list of the regex grab of all 
        of the variable, function and class names. 
        string: stores the sorted string from the list before 
        processing.
    '''
    if len(data) == 0:
	    return(0.0)
    else:
        data = str(data)
    ## isolate every variable, class, and function name 
    variables_list = re.findall(
        r'(\w+)(?=\s=)|(\w+)(?==)|(?<=def\s)(\w+)|(?<=class\s)(\w+)'
        , data)

    ## trim off the excess empty strings that regex generates
    string = ''
    if not variables_list:
        return(0.0)
    else:
        for i in variables_list:
            string += "".join(map(str, i)) + " "
    if string:
        string_list  = string.split(' ')
        temp = 0
        for i in string_list:
            temp += len(i)
        average = temp /(len(string_list) + 1)
        return(average)


def get_variable_name_entropy(data):
    '''Takes in a python .py file as a string in data. Picks out all 
    of the function, variable and class names and stores them in a 
    seperate string to make an entropy calculation. 
        data: input .py string information.
        variables_list: stores the list of the regex grab of all 
        of the variable, function and class names. 
        string: stores the sorted string from the list before 
        processing.
    '''
    if len(data) == 0:
	    return(0.0)
    else:
        data = str(data)
    ## isolate every variable, class, and function name 
    variables_list = re.findall(
        r'(\w+)(?=\s=)|(\w+)(?==)|(?<=def\s)(\w+)|(?<=class\s)(\w+)'
        , data)
    # print(variables_list)
    
    ## trim off the excess empty strings that regex generates
    string = ''
    if not variables_list:
        return(0.0)
    else:
        for i in variables_list:
            # print("".join(map(str, i)))
            string += "".join(map(str, i)) + " "
    if string:
        # print(string)
        return(get_entropy(string) )


def conatins_IP_addresses(data):
    '''Takes in a python .py file as a string in data. Picks out all 
    of the ip addresses and returns true if the data contains ip 
    addresses. 
        data: input .py string information.
        variables_list: stores the list of the regex grab of all 
        the ip addresses. 
        string: stores the cherry picked string from the list before 
        processing.
    '''
    if len(data) == 0:
	    return(0.0)
    else:
        data = str(data)
    ## isolate every variable, class, and function name 
    variables_list = re.findall(
        r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
        , data)
    string = ''
    if not variables_list:
        pass
    else:
        for i in variables_list:
            # print("".join(map(str, i)))
            string += "".join(map(str, i)) + " "
    if string:
        return(1)  #True
    else:
        return(0) #False


#good = 1
#bad = 0
goodbad=[bad,good]
cases=[]
for goodbad_i in [0,1]:
    for subdir, dirs, files in os.walk(goodbad[goodbad_i]):
        for file in files:
            if file[-1]=="~": continue #Ignore emacs backups
            o={}
            f=open(goodbad[goodbad_i]+file,"r")
            data=f.read().encode("ascii")       ## We need encode for hashing, buuuuuuuut...
            stringData = data.decode("ascii")   ## .encode breaks re searches and abstract syntax trees (mostly)
            f.close()
            # print(stringData)       ## test prints
            # print(data)           ## test prints
            m=hashlib.md5()     # hash that badboy!!
            m.update(data)
            digest=m.hexdigest()
            # print(digest)         ## test prints
            o["Name"]=file
            o["md5"]=digest
            o["entropy"]=get_entropy(data)
            o["imports"]=data.count(b"import")
            # o["Average variable name length"]=
            o["good"]=data.count(b"good")
            o["bad"]=data.count(b"bad")
            o["line count"]=stringData.count("\n")
            o["mean name length"]=get_average_name_length(stringData)
            o["variable entropy"]=get_variable_name_entropy(stringData)
            o["contains ip address"]=conatins_IP_addresses(stringData)
            o["legitimate"]=goodbad_i
            # print(o)              ## test prints
            cases.append(o)



f=open(location_dir+"/data_ab.csv", "w")
f.write("|".join(headers)+"\n")
for case in cases:
    f.write("|".join([str(case[i]) for i in headers])+"\n")
f.close()

